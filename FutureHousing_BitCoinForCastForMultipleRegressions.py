# -*- coding: utf-8 -*-
"""
Created on Sun Nov 17 22:11:48 2024

@author: Armanis
"""

import pandas_datareader as pdr
from darts import TimeSeries
from darts.models import LinearRegressionModel, ARIMA, ExponentialSmoothing, Prophet, NBEATSModel
import matplotlib.pyplot as plt
from darts.metrics import mae, rmse
import statsmodels.api as sm
import yfinance as yf
import pandas as pd

# Load and preprocess housing price data (S&P/Case-Shiller U.S. Home Price Index)
housing_data = pdr.DataReader('CSUSHPINSA', 'fred', start='2000-01-01').dropna()
housing_data = housing_data.resample('M').last()  # Monthly frequency

# Convert to Darts TimeSeries for housing data
housing_data = housing_data.rename(columns={'CSUSHPINSA': 'Price'})
housing_data['Date'] = housing_data.index
housing_ts = TimeSeries.from_dataframe(housing_data, time_col='Date', value_cols='Price')

# Create lagged features for OLS regression
housing_data_lagged = housing_data.copy()
housing_data_lagged['Lag1'] = housing_data_lagged['Price'].shift(1)
housing_data_lagged['Lag2'] = housing_data_lagged['Price'].shift(2)
housing_data_lagged['Lag3'] = housing_data_lagged['Price'].shift(3)

# Drop the rows with NaN values generated by shifting
housing_data_lagged = housing_data_lagged.dropna()

# Define the dependent (y) and independent (X) variables for OLS
X = housing_data_lagged[['Lag1', 'Lag2', 'Lag3']]
y = housing_data_lagged['Price']

# Add a constant (intercept) to the independent variables
X = sm.add_constant(X)

# Fit the OLS regression model
ols_model = sm.OLS(y, X).fit()

# Print the summary of the OLS model
print(ols_model.summary())

# Plot the actual vs predicted values from the OLS model
predictions = ols_model.predict(X)
plt.figure(figsize=(10, 6))
plt.plot(housing_data_lagged['Date'], y, label='Actual Housing Prices')
plt.plot(housing_data_lagged['Date'], predictions, label='Predicted Housing Prices', linestyle='--')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Price')
plt.title('OLS Regression: Actual vs Predicted Housing Prices')
plt.show()

#%%

# Train-test split (60% training, 40% validation)
train, val = housing_ts.split_before(0.6)

# Initialize models
arima_model = ARIMA()  
ets_model = ExponentialSmoothing()  
prophet_model = Prophet()  
linear_regression_model = LinearRegressionModel(lags=12)
nbeats_model = NBEATSModel(input_chunk_length=24, output_chunk_length=12)

# Fit models
arima_model.fit(train)
ets_model.fit(train)
prophet_model.fit(train)
linear_regression_model.fit(train)
nbeats_model.fit(train)

# Forecast horizon
forecast_horizon = len(val)

# Predict with each model
arima_forecast = arima_model.predict(forecast_horizon)
ets_forecast = ets_model.predict(forecast_horizon)
prophet_forecast = prophet_model.predict(forecast_horizon)
lr_forecast = linear_regression_model.predict(forecast_horizon)
nbeats_forecast = nbeats_model.predict(forecast_horizon)

# Plot the results
plt.figure(figsize=(10, 6))
train.plot(label='Train')
val.plot(label='Actual (Validation)', lw=2)
arima_forecast.plot(label='ARIMA Forecast', lw=2)
ets_forecast.plot(label='ETS Forecast', lw=2)
prophet_forecast.plot(label='Prophet Forecast', lw=2)
lr_forecast.plot(label='Linear Regression Forecast', lw=2)
nbeats_forecast.plot(label='N-BEATS Forecast', lw=2)
plt.title('Model Comparison: ARIMA, ETS, Prophet, Linear Regression, and N-BEATS for Housing Prices')
plt.legend()
plt.show()



#%% Refit models on full data and predict future values
arima_model.fit(housing_ts)
ets_model.fit(housing_ts)
prophet_model.fit(housing_ts)
linear_regression_model.fit(housing_ts)
nbeats_model.fit(housing_ts)

# Forecast horizon for future predictions (e.g., next 24 months)
forecast_horizon_future = 24

arima_future_forecast = arima_model.predict(forecast_horizon_future)
ets_future_forecast = ets_model.predict(forecast_horizon_future)
prophet_future_forecast = prophet_model.predict(forecast_horizon_future)
lr_future_forecast = linear_regression_model.predict(forecast_horizon_future)
nbeats_future_forecast = nbeats_model.predict(forecast_horizon_future)

# Plot future forecasts
plt.figure(figsize=(10, 6))
housing_ts.plot(label='Full Sample')

arima_future_forecast.plot(label='ARIMA Future Forecast', lw=2)
ets_future_forecast.plot(label='ETS Future Forecast', lw=2)
prophet_future_forecast.plot(label='Prophet Future Forecast', lw=2)
lr_future_forecast.plot(label='Linear Regression Future Forecast', lw=2)
nbeats_future_forecast.plot(label='N-BEATS Future Forecast', lw=2)


# Zoom into the range from 2024 to 2034 using plt.xlim()
plt.xlim(pd.Timestamp('2022-01-01'), pd.Timestamp('2027-12-31'))  # Set the x-axis limits

plt.title('Future Forecast: ARIMA, ETS, Prophet, Linear Regression, N-BEATS (Next 24 Months)')
plt.legend()
plt.show()


#%%
########  Bitcoin Section     ###########################

# Load and preprocess data for Bitcoin using yfinance
df = yf.download('BTC-USD', start='2020-01-01')  # Bitcoin data from Yahoo Finance
df = df[['Adj Close']]  # Use adjusted close price
df = df.dropna()  # Drop missing values


# Rename the adjusted close column to 'Price' for consistency
df = df.rename(columns={'Adj Close': 'Price'})



# Convert to Darts TimeSeries for Bitcoin data
bitcoin_ts = TimeSeries.from_dataframe(df, value_cols='Price', freq='D')


# Create lagged features for OLS regression
df_lagged = df.copy()
df_lagged['Lag1'] = df_lagged['Price'].shift(1)
df_lagged['Lag2'] = df_lagged['Price'].shift(2)
df_lagged['Lag3'] = df_lagged['Price'].shift(3)

# Drop rows with NaN values generated by shifting
df_lagged = df_lagged.dropna()

# Define the dependent (y) and independent (X) variables for OLS
X = df_lagged[['Lag1', 'Lag2', 'Lag3']]  # Using previous 3 days as features
y = df_lagged['Price']  # Price is the target variable

# Add a constant (intercept) to the independent variables
X = sm.add_constant(X)

# Fit the OLS regression model
ols_model = sm.OLS(y, X).fit()

# Print the summary of the OLS model
print(ols_model.summary())

# Plot the actual vs predicted values from the OLS model
predictions = ols_model.predict(X)
plt.figure(figsize=(10, 6))
plt.plot(df_lagged.index, y, label='Actual Bitcoin Prices')
plt.plot(df_lagged.index, predictions, label='Predicted Bitcoin Prices', linestyle='--')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title('OLS Regression: Actual vs Predicted Bitcoin Prices')
plt.show()

#%%


# Train-test split (60% training, 40% validation)
train, val = bitcoin_ts.split_before(0.6)

# Initialize models
arima_model = ARIMA()  
ets_model = ExponentialSmoothing()  
prophet_model = Prophet()  
linear_regression_model = LinearRegressionModel(lags=12)  # 12 lags for regression
nbeats_model = NBEATSModel(input_chunk_length=24, output_chunk_length=12)  # N-BEATS with chunk length settings

# Fit models to training data
arima_model.fit(train)
ets_model.fit(train)
prophet_model.fit(train)
linear_regression_model.fit(train)
nbeats_model.fit(train)

# Forecast horizon (length of validation set)
forecast_horizon = len(val)

# Predict with each model
arima_forecast = arima_model.predict(forecast_horizon)
ets_forecast = ets_model.predict(forecast_horizon)
prophet_forecast = prophet_model.predict(forecast_horizon)
lr_forecast = linear_regression_model.predict(forecast_horizon)
nbeats_forecast = nbeats_model.predict(forecast_horizon)

# Plot the results
plt.figure(figsize=(10, 6))
train.plot(label='Train')
val.plot(label='Actual (Validation)', lw=2)
arima_forecast.plot(label='ARIMA Forecast', lw=2)
ets_forecast.plot(label='ETS Forecast', lw=2)
prophet_forecast.plot(label='Prophet Forecast', lw=2)
lr_forecast.plot(label='Linear Regression Forecast', lw=2)
nbeats_forecast.plot(label='N-BEATS Forecast', lw=2)
plt.title('Model Comparison: ARIMA, ETS, Prophet, Linear Regression, and N-BEATS for Bitcoin Prices')
plt.legend()
plt.show()


#%% Refit models on the full data and predict future values
arima_model.fit(bitcoin_ts)
ets_model.fit(bitcoin_ts)
prophet_model.fit(bitcoin_ts)
linear_regression_model.fit(bitcoin_ts)
nbeats_model.fit(bitcoin_ts)

# Forecast horizon for future predictions (next 24 days)
forecast_horizon_future = 24

arima_future_forecast = arima_model.predict(forecast_horizon_future)
ets_future_forecast = ets_model.predict(forecast_horizon_future)
prophet_future_forecast = prophet_model.predict(forecast_horizon_future)
lr_future_forecast = linear_regression_model.predict(forecast_horizon_future)
nbeats_future_forecast = nbeats_model.predict(forecast_horizon_future)

# Plot future forecasts
plt.figure(figsize=(10, 6))
bitcoin_ts.plot(label='Full Sample')

arima_future_forecast.plot(label='ARIMA Future Forecast', lw=2)
ets_future_forecast.plot(label='ETS Future Forecast', lw=2)
prophet_future_forecast.plot(label='Prophet Future Forecast', lw=2)
lr_future_forecast.plot(label='Linear Regression Future Forecast', lw=2)
nbeats_future_forecast.plot(label='N-BEATS Future Forecast', lw=2)

plt.title('Future Forecast: ARIMA, ETS, Prophet, Linear Regression, N-BEATS (Next 24 Days)')
plt.legend()
plt.show()


#BTW IT Takes a LONG time to load bitcoin data

print("Bitcoin is more volatile, making it harder to forecast accurately with simpler models like AutoARIMA or Linear Regression.")
print("N-Beats performs better for Bitcoin due to its ability to capture complex patterns.")
print("HPI shows smoother trends, so simpler models like Linear Regression and AutoARIMA perform reasonably well.")


# #%% # use to Calculate performance
# # Calculate performance metrics
# from darts.metrics import mae, rmse

# print("MAE - ARIMA:", mae(val, arima_forecast))
# print("MAE - ETS:", mae(val, ets_forecast))
# print("MAE - Prophet:", mae(val, prophet_forecast))

# print("RMSE - ARIMA:", rmse(val, arima_forecast))
# print("RMSE - ETS:", rmse(val, ets_forecast))
# print("RMSE - Prophet:", rmse(val, prophet_forecast))
